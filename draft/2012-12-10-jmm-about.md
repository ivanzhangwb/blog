---
layout: post
date: 2012-12-10
layout: post
title: "说说JAVA内存模型"
permalink: "about-jmm"
categories:
- JVM
tags:
- JVM
---

#### 关于物理计算机的缓存一致性
聊JMM之前，我们来看下物理计算机中面临的缓存一致性问题:  
 为了进一步提升计算机的计算速度，几乎所有现代计算机系统都会在`CPU`与`内存`之间加入一层高速缓存来作为缓冲。  
  `这样将运算需要使用到的数据复制到缓存中、让运算快速进行，当运算结束后再从缓存同步回内存中，这样CPU就无须等待缓慢的内存读写了（相对CPU的运算速度，内存的读写速度那还是慢很多的）`  
 这种方案虽然有利于运算速度的提升，但是也引入了新的问题，那就是`缓存一致性`问题：   
 在多个CPU的系统中，每个CPU都有自己的高速缓存， 而它们又共享同一块内存， 也就是说，有可能多个缓存都要去同一块内存地址获取某个值， 各自运算以后，再把值回写到内存中。   
 那么问题来了， 如何保证顺序？  
 到底是A先写，还是B先写？ 到底是A先于B写之前读，还是？ 所以纠结了。。 这就是所谓的 `缓存一致性`问题  
 为了解决这类问题，CPU在访问高速缓存的时候，需要遵循一定的协议， 比如`MSI, MESI,MOSI,Synapse… 等等协议`
   
 <img src="http://i01.lw.aliimg.com/wj/ur/urwj_c1a837e1_534_194.jpg" width="650px"/>
 
 而JMM中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。  
 
#### JAVA内存模型
Java内存模型用来支持JAVA的跨平台，由于各种硬件环境下的内存也不尽一样。所以JAVA虚拟机也同样需要一种抽象的JAVA 内存模型来屏蔽掉各种硬件环境下内存模型的访问差异。 其官方的定义规范文档在：  
_[JSR-133]_ <http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf>  

说白了，JMM定义的主要内容是关于 将JVM中的变量存储到内存和从内存中读取变量这样的底层细节。  
具体的协议内容就不细聊了，可以参考上面的链接仔细了解下。

在JMM中，每条线程都有自己的工作内存（与前面说的CPU的高速缓存类似），线程的工作内存中保存了被该线程使用到的变量的主内存的副本， 线程对变量的所有操作，都是在工作内存中进行的，而不能直接读写主内存的变量。（就算是volatile类型的变量，也有其工作内存的拷贝） 而不同的线程之间，工作内存是隔离的，也就是说无法相互进行工作内存的访问。

<img src="http://i01.lw.aliimg.com/z5/ur/urz5_2de5f62a_558_217.jpg" width="650px"/>  

对于一个变量如果从主内存拷贝到工作内存、如果从工作内存同步回主内存，JMM中主要通过以下操作来完成:      

* lock : 作用于主内存的变量，它把变量标示为一条线程独占状态.  
* unlock : 作用与主内存变量，将处于锁定的变量释放出来。释放后，其他线程才能锁定这个变量。
* read : 将变量的值从主内存 传输 到线程的工作内存中
* load : 将read操作从主内存中得到的值，放入到工作内存的变量副本中。
* use : 把工作内存的值传递给执行引擎。
* assign : 把执行引擎处接收到的值赋值给工作内存的变量，
* store : 把工作内存的一个变量的值传送给主内存
* write : 把store操作从工作内存中的变量值放入到内存的变量中。

这些操作的顺序在JMM中没有保证必须是连续执行的。 

待续……

